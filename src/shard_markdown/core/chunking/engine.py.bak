"""Main chunking engine that selects appropriate strategy."""

from functools import lru_cache
from typing import ClassVar

from ...utils.errors import ProcessingError
from ...utils.logging import get_logger
from ..models import ChunkingConfig, DocumentChunk, MarkdownAST
from .fixed import FixedSizeChunker
from .structure import StructureAwareChunker


logger = get_logger(__name__)


class ChunkingEngine:
    """Main chunking engine with strategy selection and performance optimizations."""

    # Class-level strategy cache to avoid recreating strategies for identical configs
    _strategy_cache: ClassVar[dict[str, dict[str, object]]] = {}

    def __init__(self, config: ChunkingConfig):
        """Initialize chunking engine with configuration.

        Args:
            config: Chunking configuration
        """
        self.config = config
        self.strategies = self._get_strategies(config)

    @classmethod
    def _get_strategies(cls, config: ChunkingConfig) -> dict[str, object]:
        """Get or create cached strategies for the given configuration.

        This method implements caching to avoid recreating strategy instances
        for identical configurations, improving performance.

        Args:
            config: Chunking configuration

        Returns:
            Dictionary of strategy name to strategy instance
        """
        # Create a cache key from config attributes
        cache_key = f"{config.chunk_size}_{config.overlap}_{config.method}_{config.respect_boundaries}"

        if cache_key not in cls._strategy_cache:
            cls._strategy_cache[cache_key] = {
                "structure": StructureAwareChunker(config),
                "fixed": FixedSizeChunker(config),
            }
            logger.debug("Created new strategy instances for config: %s", cache_key)
        else:
            logger.debug("Using cached strategy instances for config: %s", cache_key)

        return cls._strategy_cache[cache_key]

    def chunk_document(self, ast: MarkdownAST) -> list[DocumentChunk]:
        """Chunk document using configured strategy.

        Args:
            ast: Parsed markdown AST

        Returns:
            List of document chunks

        Raises:
            ProcessingError: If chunking fails
        """
        if not ast.elements:
            logger.warning("No elements in AST to chunk")
            return []

        strategy_name = self.config.method
        if strategy_name not in self.strategies:
            raise ProcessingError(
                f"Unknown chunking strategy: {strategy_name}",
                error_code=1310,
                context={
                    "strategy": strategy_name,
                    "available_strategies": list(self.strategies.keys()),
                },
            )

        try:
            chunker = self.strategies[strategy_name]
            chunks = chunker.chunk_document(ast)

            # Validate chunks
            self._validate_chunks(chunks)

            # Add chunk IDs and additional metadata
            for i, chunk in enumerate(chunks):
                chunk.id = f"chunk_{i:04d}"
                chunk.add_metadata("chunk_index", i)
                chunk.add_metadata("total_chunks", len(chunks))

            logger.info("Successfully chunked document into %s chunks", len(chunks))
            return chunks

        except (AttributeError, ValueError, TypeError) as e:
            if isinstance(e, ProcessingError):
                raise

            raise ProcessingError(
                f"Chunking failed with strategy '{strategy_name}': {str(e)}",
                error_code=1311,
                context={"strategy": strategy_name, "ast_elements": len(ast.elements)},
                cause=e,
            ) from e

    @lru_cache(maxsize=128)
    def _validate_chunks_cached(
        self, chunk_count: int, max_size: int, total_size: int
    ) -> bool:
        """Cached validation for common chunk patterns.

        Args:
            chunk_count: Number of chunks
            max_size: Maximum allowed chunk size
            total_size: Total content size

        Returns:
            True if validation passes
        """
        # Basic validation logic that can be cached
        if chunk_count == 0:
            return True

        # Check if the pattern looks reasonable
        avg_size = total_size / chunk_count if chunk_count > 0 else 0
        return avg_size <= max_size

    def _validate_chunks(self, chunks: list[DocumentChunk]) -> None:
        """Validate generated chunks with performance optimizations.

        Args:
            chunks: List of chunks to validate

        Raises:
            ProcessingError: If validation fails
        """
        if not chunks:
            return

        # Fast path: use cached validation for common patterns
        max_allowed_size = self.config.chunk_size * 1.5
        total_size = sum(len(chunk.content) for chunk in chunks)

        if self._validate_chunks_cached(len(chunks), int(max_allowed_size), total_size):
            # Perform detailed validation only if fast path suggests issues
            pass

        # Check for empty chunks
        empty_chunks = [
            i for i, chunk in enumerate(chunks) if not chunk.content.strip()
        ]
        if empty_chunks:
            raise ProcessingError(
                f"Generated empty chunks at positions: {empty_chunks}",
                error_code=1312,
                context={"empty_chunk_indices": empty_chunks},
            )

        # Check for oversized chunks (allow some tolerance)
        oversized_chunks = [
            i for i, chunk in enumerate(chunks) if len(chunk.content) > max_allowed_size
        ]

        if oversized_chunks:
            raise ProcessingError(
                f"Generated chunks exceed size limits at positions: {oversized_chunks}",
                error_code=1313,
                context={
                    "oversized_chunk_indices": oversized_chunks,
                    "max_allowed_size": max_allowed_size,
                    "configured_size": self.config.chunk_size,
                },
            )

        logger.debug("Validated %s chunks successfully", len(chunks))

    @classmethod
    def clear_cache(cls) -> None:
        """Clear the strategy cache.

        This method can be called to free memory if needed.
        """
        cls._strategy_cache.clear()
        logger.debug("Cleared chunking strategy cache")
